# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    cub3D_projection_bonus.c.bak                     :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: pmagnero <pmagnero@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2024/03/11 13:27:14 by pmagnero          #+#    #+#              #
#    Updated: 2024/04/05 12:19:12 by pmagnero         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

#include "../../includes/cub3D.h"

void	rx(int *y, int *z, t_vars *vars)
{
	int	yy;

	yy = *y;
	*y = yy * vars->trig.cosx + *z * vars->trig.sinx;
	*z = *z * vars->trig.cosx - yy * vars->trig.sinx;
}

void	ry(int *x, int *z, t_vars *vars)
{
	int	xx;

	xx = *x;
	*x = xx * vars->trig.cosy + *z * vars->trig.siny;
	*z = *z * vars->trig.cosy - xx * vars->trig.siny;
}

void	rz(int *x, int *y, t_vars *vars)
{
	int	xx;
	int	yy;

	xx = *x;
	yy = *y;
	*x = xx * vars->trig.cosz - yy * vars->trig.sinz;
	*y = yy * vars->trig.cosz + xx * vars->trig.sinz;
}

void	inittrigo(t_vars *vars)
{
	vars->trig.cosx = cos(vars->mouse.xangle);
	vars->trig.sinx = sin(vars->mouse.xangle);
	vars->trig.cosy = cos(vars->mouse.yangle);
	vars->trig.siny = sin(vars->mouse.yangle);
	vars->trig.cosz = cos(vars->mouse.zangle);
	vars->trig.sinz = sin(vars->mouse.zangle);
}

void	convertpoint(t_vars *vars, t_point *b, t_point a)
{
	(void)a;
	b->z *= vars->mouse.zoom / vars->mouse.zheight;
	ry(&b->x, &b->z, vars);
	rx(&b->y, &b->z, vars);
	rz(&(b->x), &(b->y), vars);
}

	// float	r;
	// float	theta;
	// float	phi;
	// if (vars->mode == 1)
	// {
	// b->z *= 10;
	// a.x = 1;
	// r = vars->img[EMAP].width / 2;
	// theta = b->x / r;
	// phi = 2 * atan(exp(b->y / r)) - M_PI / 2;
	// b->x += 500.0f * cos(phi) * cos(theta);
	// b->y += 500.0f * cos(phi) * sin(theta);
	// b->z += 500.0f * sin(phi);
	// }